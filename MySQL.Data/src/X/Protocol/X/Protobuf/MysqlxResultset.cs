// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mysqlx_resultset.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Resultset {

  /// <summary>Holder for reflection information generated from mysqlx_resultset.proto</summary>
  internal static partial class MysqlxResultsetReflection {

    #region Descriptor
    /// <summary>File descriptor for mysqlx_resultset.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MysqlxResultsetReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZteXNxbHhfcmVzdWx0c2V0LnByb3RvEhBNeXNxbHguUmVzdWx0c2V0IhgK",
            "FkZldGNoRG9uZU1vcmVPdXRQYXJhbXMiGQoXRmV0Y2hEb25lTW9yZVJlc3Vs",
            "dHNldHMiCwoJRmV0Y2hEb25lIqkDCg5Db2x1bW5NZXRhRGF0YRI4CgR0eXBl",
            "GAEgASgOMiouTXlzcWx4LlJlc3VsdHNldC5Db2x1bW5NZXRhRGF0YS5GaWVs",
            "ZFR5cGUSDAoEbmFtZRgCIAEoDBIVCg1vcmlnaW5hbF9uYW1lGAMgASgMEg0K",
            "BXRhYmxlGAQgASgMEhYKDm9yaWdpbmFsX3RhYmxlGAUgASgMEg4KBnNjaGVt",
            "YRgGIAEoDBIPCgdjYXRhbG9nGAcgASgMEhEKCWNvbGxhdGlvbhgIIAEoBBIZ",
            "ChFmcmFjdGlvbmFsX2RpZ2l0cxgJIAEoDRIOCgZsZW5ndGgYCiABKA0SDQoF",
            "ZmxhZ3MYCyABKA0SFAoMY29udGVudF90eXBlGAwgASgNIowBCglGaWVsZFR5",
            "cGUSCAoETk9ORRAAEggKBFNJTlQQARIICgRVSU5UEAISCgoGRE9VQkxFEAUS",
            "CQoFRkxPQVQQBhIJCgVCWVRFUxAHEggKBFRJTUUQChIMCghEQVRFVElNRRAM",
            "EgcKA1NFVBAPEggKBEVOVU0QEBIHCgNCSVQQERILCgdERUNJTUFMEBIiFAoD",
            "Um93Eg0KBWZpZWxkGAEgAygMKkAKEUNvbnRlbnRUeXBlX0JZVEVTEgoKBkNC",
            "Tk9ORRAAEgwKCEdFT01FVFJZEAESCAoESlNPThACEgcKA1hNTBADKjoKFENv",
            "bnRlbnRUeXBlX0RBVEVUSU1FEgoKBkNETk9ORRAAEggKBERBVEUQARIMCghE",
            "QVRFVElNRRACQhkKF2NvbS5teXNxbC5jai54LnByb3RvYnVmYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Mysqlx.Resultset.ContentType_BYTES), typeof(global::Mysqlx.Resultset.ContentType_DATETIME), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDoneMoreOutParams), global::Mysqlx.Resultset.FetchDoneMoreOutParams.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDoneMoreResultsets), global::Mysqlx.Resultset.FetchDoneMoreResultsets.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDone), global::Mysqlx.Resultset.FetchDone.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.ColumnMetaData), global::Mysqlx.Resultset.ColumnMetaData.Parser, new[]{ "Type", "Name", "OriginalName", "Table", "OriginalTable", "Schema", "Catalog", "Collation", "FractionalDigits", "Length", "Flags", "ContentType" }, null, new[]{ typeof(global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.Row), global::Mysqlx.Resultset.Row.Parser, new[]{ "Field" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///  a hint about the higher-level encoding of a BYTES field
  ///
  ///  ====== ====== ===========
  ///  type   value  description
  ///  ====== ====== ===========
  ///  BYTES  0x0001 GEOMETRY (WKB encoding)
  ///  BYTES  0x0002 JSON (text encoding)
  ///  BYTES  0x0003 XML (text encoding)
  ///  ====== ====== ===========
  ///
  ///  .. note::
  ///    this list isn't comprehensive. As guideline: the field's value is expected
  ///    to pass a validator check on client and server if this field is set.
  ///    If the server adds more internal datatypes that rely on BLOB storage
  ///    like image manipulation, seeking into complex types in BLOBs, ... more
  ///    types will be added.
  /// </summary>
  internal enum ContentType_BYTES {
    [pbr::OriginalName("CBNONE")] Cbnone = 0,
    [pbr::OriginalName("GEOMETRY")] Geometry = 1,
    [pbr::OriginalName("JSON")] Json = 2,
    [pbr::OriginalName("XML")] Xml = 3,
  }

  /// <summary>
  ///  a hint about the higher-level encoding of a DATETIME field
  ///
  ///  ======   ====== ===========
  ///  type     value  description
  ///  ======== ====== ===========
  ///  DATE     0x0001 DATETIME contains only date part
  ///  DATETIME 0x0002 DATETIME contains both date and time parts
  ///  ======   ====== ===========
  /// </summary>
  internal enum ContentType_DATETIME {
    [pbr::OriginalName("CDNONE")] Cdnone = 0,
    [pbr::OriginalName("DATE")] Date = 1,
    [pbr::OriginalName("DATETIME")] Datetime = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  ///  resultsets are finished, OUT paramset is next
  /// </summary>
  internal sealed partial class FetchDoneMoreOutParams : pb::IMessage<FetchDoneMoreOutParams> {
    private static readonly pb::MessageParser<FetchDoneMoreOutParams> _parser = new pb::MessageParser<FetchDoneMoreOutParams>(() => new FetchDoneMoreOutParams());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchDoneMoreOutParams> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreOutParams() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreOutParams(FetchDoneMoreOutParams other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreOutParams Clone() {
      return new FetchDoneMoreOutParams(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchDoneMoreOutParams);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchDoneMoreOutParams other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchDoneMoreOutParams other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  ///  resultset and out-params are finished, but more resultsets available
  /// </summary>
  internal sealed partial class FetchDoneMoreResultsets : pb::IMessage<FetchDoneMoreResultsets> {
    private static readonly pb::MessageParser<FetchDoneMoreResultsets> _parser = new pb::MessageParser<FetchDoneMoreResultsets>(() => new FetchDoneMoreResultsets());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchDoneMoreResultsets> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreResultsets() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreResultsets(FetchDoneMoreResultsets other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDoneMoreResultsets Clone() {
      return new FetchDoneMoreResultsets(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchDoneMoreResultsets);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchDoneMoreResultsets other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchDoneMoreResultsets other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  ///  all resultsets are finished
  /// </summary>
  internal sealed partial class FetchDone : pb::IMessage<FetchDone> {
    private static readonly pb::MessageParser<FetchDone> _parser = new pb::MessageParser<FetchDone>(() => new FetchDone());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FetchDone> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDone() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDone(FetchDone other) : this() {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FetchDone Clone() {
      return new FetchDone(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FetchDone);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FetchDone other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FetchDone other) {
      if (other == null) {
        return;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
        }
      }
    }

  }

  /// <summary>
  ///  meta data of a Column
  ///
  ///  .. note:: the encoding used for the different ``bytes`` fields in the meta data is externally
  ///    controlled.
  ///    .. seealso:: https://dev.mysql.com/doc/refman/8.0/en/charset-connection.html
  ///
  ///  .. note::
  ///    The server may not set the ``original_{table|name}`` fields if they are equal to the plain
  ///    ``{table|name}`` field.
  ///
  ///    A client has to reconstruct it like::
  ///
  ///      if .original_name is empty and .name is not empty:
  ///        .original_name = .name
  ///
  ///      if .original_table is empty and .table is not empty:
  ///        .original_table = .table
  ///
  ///  .. note::
  ///    ``compact metadata format`` can be requested by the client. In that case only ``.type`` is set and
  ///    all other fields are empty.
  ///
  ///  :param type:
  ///    .. table:: Expected Datatype of Mysqlx.Resultset.Row per SQL Type for non NULL values
  ///
  ///      ================= ============ ======= ========== ====== ========
  ///      SQL Type          .type        .length .frac_dig  .flags .charset
  ///      ================= ============ ======= ========== ====== ========
  ///      TINY              SINT         x
  ///      TINY UNSIGNED     UINT         x                  x
  ///      SHORT             SINT         x
  ///      SHORT UNSIGNED    UINT         x                  x
  ///      INT24             SINT         x
  ///      INT24 UNSIGNED    UINT         x                  x
  ///      INT               SINT         x
  ///      INT UNSIGNED      UINT         x                  x
  ///      LONGLONG          SINT         x
  ///      LONGLONG UNSIGNED UINT         x                  x
  ///      DOUBLE            DOUBLE       x       x          x
  ///      FLOAT             FLOAT        x       x          x
  ///      DECIMAL           DECIMAL      x       x          x
  ///      VARCHAR,CHAR,...  BYTES        x                  x      x
  ///      GEOMETRY          BYTES
  ///      TIME              TIME         x
  ///      DATE              DATETIME     x
  ///      DATETIME          DATETIME     x
  ///      YEAR              UINT         x                  x
  ///      TIMESTAMP         DATETIME     x
  ///      SET               SET                                    x
  ///      ENUM              ENUM                                   x
  ///      NULL              BYTES
  ///      BIT               BIT          x
  ///      ================= ============ ======= ========== ====== ========
  ///
  ///    .. note:: the SQL "NULL" value is sent as an empty field value in :protobuf:msg:`Mysqlx.Resultset::Row`
  ///    .. seealso:: protobuf encoding of primitive datatypes are decribed in https://developers.google.com/protocol-buffers/docs/encoding
  ///
  ///    SINT
  ///
  ///      ``.length``
  ///        maximum number of displayable decimal digits (including minus sign) of the type
  ///
  ///        .. note::
  ///          valid range is 0-255, but usually you'll see 1-20
  ///
  ///        =============== ==
  ///        SQL Type        max digits per type
  ///        =============== ==
  ///        TINY SIGNED      4
  ///        SHORT SIGNED     6
  ///        INT24 SIGNED     8
  ///        INT SIGNED      11
  ///        LONGLONG SIGNED 20
  ///        =============== ==
  ///
  ///        .. seealso:: definition of ``M`` in https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
  ///
  ///      ``value``
  ///        variable length encoded signed 64 integer
  ///
  ///    UINT
  ///
  ///      ``.flags &amp; 1`` (zerofill)
  ///        the client has to left pad with 0's up to .length
  ///
  ///      ``.length``
  ///        maximum number of displayable decimal digits of the type
  ///
  ///        .. note::
  ///          valid range is 0-255, but usually you'll see 1-20
  ///
  ///        ================= ==
  ///        SQL Type          max digits per type
  ///        ================= ==
  ///        TINY UNSIGNED      3
  ///        SHORT UNSIGNED     5
  ///        INT24 UNSIGNED     8
  ///        INT UNSIGNED      10
  ///        LONGLONG UNSIGNED 20
  ///        ================= ==
  ///
  ///        .. seealso:: definition of ``M`` in https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
  ///
  ///      ``value``
  ///        variable length encoded unsigned 64 integer
  ///
  ///    BIT
  ///
  ///      ``.length``
  ///        maximum number of displayable binary digits
  ///
  ///        .. note:: valid range for M of the ``BIT`` type is 1 - 64
  ///        .. seealso:: https://dev.mysql.com/doc/refman/8.0/en/numeric-type-overview.html
  ///
  ///      ``value``
  ///        variable length encoded unsigned 64 integer
  ///
  ///    DOUBLE
  ///
  ///      ``.length``
  ///        maximum number of displayable decimal digits (including the decimal point and ``.fractional_digits``)
  ///
  ///      ``.fractional_digits``
  ///        maximum number of displayable decimal digits following the decimal point
  ///
  ///      ``value``
  ///        encoded as Protobuf's 'double'
  ///
  ///    FLOAT
  ///
  ///      ``.length``
  ///        maximum number of displayable decimal digits (including the decimal point and ``.fractional_digits``)
  ///
  ///      ``.fractional_digits``
  ///        maximum number of displayable decimal digits following the decimal point
  ///
  ///      ``value``
  ///        encoded as Protobuf's 'float'
  ///
  ///    BYTES, ENUM
  ///      BYTES is used for all opaque byte strings that may have a charset
  ///
  ///        * TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB
  ///        * TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT
  ///        * VARCHAR, VARBINARY
  ///        * CHAR, BINARY
  ///        * ENUM
  ///
  ///      ``.length``
  ///        the maximum length of characters of the underlying type
  ///
  ///      ``.flags &amp; 1`` (rightpad)
  ///        if the length of the field is less than ``.length``, the receiver is
  ///        supposed to add padding characters to the right end of the string.
  ///        If the ``.charset`` is "binary", the padding character is ``0x00``,
  ///        otherwise it is a space character as defined by that character set.
  ///
  ///        ============= ======= ======== =======
  ///        SQL Type      .length .charset .flags
  ///        ============= ======= ======== =======
  ///        TINYBLOB      256     binary
  ///        BLOB          65535   binary
  ///        VARCHAR(32)   32      utf8
  ///        VARBINARY(32) 32      utf8_bin
  ///        BINARY(32)    32      binary   rightpad
  ///        CHAR(32)      32      utf8     rightpad
  ///        ============= ======= ======== =======
  ///
  ///      ``value``
  ///        sequence of bytes with added one extra '\0' byte at the end. To obtain the
  ///        original string, the extra '\0' should be removed.
  ///        .. note:: the length of the string can be acquired with protobuf's field length() method
  ///          length of sequence-of-bytes = length-of-field - 1
  ///        .. note:: the extra byte allows to distinguish between a NULL and empty byte sequence
  ///
  ///    TIME
  ///      A time value.
  ///
  ///      ``value``
  ///        the following bytes sequence:
  ///
  ///          ``| negate [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
  ///
  ///        * negate - one byte, should be one of: 0x00 for "+", 0x01 for "-"
  ///        * hour - optional variable length encoded unsigned64 value for the hour
  ///        * minutes - optional variable length encoded unsigned64 value for the minutes
  ///        * seconds - optional variable length encoded unsigned64 value for the seconds
  ///        * useconds - optional variable length encoded unsigned64 value for the microseconds
  ///
  ///        .. seealso:: protobuf encoding in https://developers.google.com/protocol-buffers/docs/encoding
  ///        .. note:: hour, minutes, seconds, useconds are optional if all the values to the right are 0
  ///
  ///        Example: 0x00 -> +00:00:00.000000
  ///
  ///    DATETIME
  ///      A date or date and time value.
  ///
  ///      ``value``
  ///        a sequence of variants, arranged as follows:
  ///
  ///          ``| year | month | day | [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
  ///
  ///        * year - variable length encoded unsigned64 value for the year
  ///        * month - variable length encoded unsigned64 value for the month
  ///        * day - variable length encoded unsigned64 value for the day
  ///        * hour - optional variable length encoded unsigned64 value for the hour
  ///        * minutes - optional variable length encoded unsigned64 value for the minutes
  ///        * seconds - optional variable length encoded unsigned64 value for the seconds
  ///        * useconds - optional variable length encoded unsigned64 value for the microseconds
  ///
  ///        .. note:: hour, minutes, seconds, useconds are optional if all the values to the right are 0
  ///
  ///      ``.flags &amp; 1`` (timestamp)
  ///
  ///        ============= =======
  ///        SQL Type      .flags
  ///        ============= =======
  ///        DATETIME
  ///        TIMESTAMP     1
  ///
  ///    DECIMAL
  ///      An arbitrary length number. The number is encoded as a single byte
  ///      indicating the position of the decimal point followed by the Packed BCD
  ///      encoded number. Packed BCD is used to simplify conversion to and
  ///      from strings and other native arbitrary precision math datatypes.
  ///      .. seealso:: packed BCD in https://en.wikipedia.org/wiki/Binary-coded_decimal
  ///
  ///      ``.length``
  ///        maximum number of displayable decimal digits (*excluding* the decimal point and sign, but including ``.fractional_digits``)
  ///
  ///        .. note:: should be in the range of 1 - 65
  ///
  ///      ``.fractional_digits``
  ///        is the decimal digits to display out of length
  ///
  ///        .. note:: should be in the range of 0 - 30
  ///
  ///      ``value``
  ///        the following bytes sequence:
  ///
  ///          ``| scale | BCD | sign | [0x0] |``
  ///
  ///        * scale - 8bit scale value (number of decimal digit after the '.')
  ///        * BCD - BCD encoded digits (4 bits for each digit)
  ///        * sign - sign encoded on 4 bits (0xc = "+", 0xd = "-")
  ///        * 0x0 - last 4bits if length(digits) % 2 == 0
  ///
  ///        Example: x04 0x12 0x34 0x01 0xd0 -> -12.3401
  ///
  ///    SET
  ///      A list of strings representing a SET of values.
  ///
  ///      ``value``
  ///        A sequence of 0 or more of protobuf's bytes (length prepended octets) or one of
  ///        the special sequences with a predefined meaning listed below.
  ///
  ///        Example (length of the bytes array shown in brackets):
  ///          * ``[0]`` - the NULL value
  ///          * ``[1] 0x00`` - a set containing a blank string ''
  ///          * ``[1] 0x01`` - this would be an invalid value, but is to be treated as the empty set
  ///          * ``[2] 0x01 0x00`` - a set with a single item, which is the '\0' character
  ///          * ``[8] 0x03 F O O 0x03 B A R`` - a set with 2 items: FOO,BAR
  ///
  ///  :param name: name of the column
  ///  :param original_name: name of the column before an alias was applied
  ///  :param table: name of the table the column orginates from
  ///  :param original_table: name of the table the column orginates from before an alias was applied
  ///  :param schema: schema the column originates from
  ///  :param catalog:
  ///    catalog the schema originates from
  ///
  ///    .. note::
  ///      as there is current no support for catalogs in MySQL, don't expect this field to be set.
  ///      In the MySQL C/S protocol the field had the value ``def`` all the time.
  ///
  ///  :param fractional_digits: displayed factional decimal digits for floating point and fixed point numbers
  ///  :param length: maximum count of displayable characters of .type
  ///  :param flags:
  ///    ``.type`` specific flags
  ///
  ///    ======= ====== ===========
  ///    type    value  description
  ///    ======= ====== ===========
  ///    UINT    0x0001 zerofill
  ///    DOUBLE  0x0001 unsigned
  ///    FLOAT   0x0001 unsigned
  ///    DECIMAL 0x0001 unsigned
  ///    BYTES   0x0001 rightpad
  ///    ======= ====== ===========
  ///
  ///    ====== ================
  ///    value  description
  ///    ====== ================
  ///    0x0010 NOT_NULL
  ///    0x0020 PRIMARY_KEY
  ///    0x0040 UNIQUE_KEY
  ///    0x0080 MULTIPLE_KEY
  ///    0x0100 AUTO_INCREMENT
  ///    ====== ================
  ///
  ///    default: 0
  ///  :param content_type:
  ///    a hint about the higher-level encoding of a BYTES field, for more informations
  ///    please refer to Mysqlx.Resultset.ContentType_BYTES enum.
  /// </summary>
  internal sealed partial class ColumnMetaData : pb::IMessage<ColumnMetaData> {
    private static readonly pb::MessageParser<ColumnMetaData> _parser = new pb::MessageParser<ColumnMetaData>(() => new ColumnMetaData());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ColumnMetaData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnMetaData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnMetaData(ColumnMetaData other) : this() {
      type_ = other.type_;
      name_ = other.name_;
      originalName_ = other.originalName_;
      table_ = other.table_;
      originalTable_ = other.originalTable_;
      schema_ = other.schema_;
      catalog_ = other.catalog_;
      collation_ = other.collation_;
      fractionalDigits_ = other.fractionalDigits_;
      length_ = other.length_;
      flags_ = other.flags_;
      contentType_ = other.contentType_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ColumnMetaData Clone() {
      return new ColumnMetaData(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType type_ = 0;
    /// <summary>
    ///  datatype of the field in a row
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private pb::ByteString name_ = pb::ByteString.Empty;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "original_name" field.</summary>
    public const int OriginalNameFieldNumber = 3;
    private pb::ByteString originalName_ = pb::ByteString.Empty;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString OriginalName {
      get { return originalName_; }
      set {
        originalName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "table" field.</summary>
    public const int TableFieldNumber = 4;
    private pb::ByteString table_ = pb::ByteString.Empty;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Table {
      get { return table_; }
      set {
        table_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "original_table" field.</summary>
    public const int OriginalTableFieldNumber = 5;
    private pb::ByteString originalTable_ = pb::ByteString.Empty;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString OriginalTable {
      get { return originalTable_; }
      set {
        originalTable_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "schema" field.</summary>
    public const int SchemaFieldNumber = 6;
    private pb::ByteString schema_ = pb::ByteString.Empty;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Schema {
      get { return schema_; }
      set {
        schema_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "catalog" field.</summary>
    public const int CatalogFieldNumber = 7;
    private pb::ByteString catalog_ = pb::ByteString.Empty;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Catalog {
      get { return catalog_; }
      set {
        catalog_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "collation" field.</summary>
    public const int CollationFieldNumber = 8;
    private ulong collation_;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Collation {
      get { return collation_; }
      set {
        collation_ = value;
      }
    }

    /// <summary>Field number for the "fractional_digits" field.</summary>
    public const int FractionalDigitsFieldNumber = 9;
    private uint fractionalDigits_;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint FractionalDigits {
      get { return fractionalDigits_; }
      set {
        fractionalDigits_ = value;
      }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 10;
    private uint length_;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 11;
    private uint flags_;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Flags {
      get { return flags_; }
      set {
        flags_ = value;
      }
    }

    /// <summary>Field number for the "content_type" field.</summary>
    public const int ContentTypeFieldNumber = 12;
    private uint contentType_;
    /// <summary>
    /// optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ContentType {
      get { return contentType_; }
      set {
        contentType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ColumnMetaData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ColumnMetaData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Name != other.Name) return false;
      if (OriginalName != other.OriginalName) return false;
      if (Table != other.Table) return false;
      if (OriginalTable != other.OriginalTable) return false;
      if (Schema != other.Schema) return false;
      if (Catalog != other.Catalog) return false;
      if (Collation != other.Collation) return false;
      if (FractionalDigits != other.FractionalDigits) return false;
      if (Length != other.Length) return false;
      if (Flags != other.Flags) return false;
      if (ContentType != other.ContentType) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != 0) hash ^= Type.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (OriginalName.Length != 0) hash ^= OriginalName.GetHashCode();
      if (Table.Length != 0) hash ^= Table.GetHashCode();
      if (OriginalTable.Length != 0) hash ^= OriginalTable.GetHashCode();
      if (Schema.Length != 0) hash ^= Schema.GetHashCode();
      if (Catalog.Length != 0) hash ^= Catalog.GetHashCode();
      if (Collation != 0UL) hash ^= Collation.GetHashCode();
      if (FractionalDigits != 0) hash ^= FractionalDigits.GetHashCode();
      if (Length != 0) hash ^= Length.GetHashCode();
      if (Flags != 0) hash ^= Flags.GetHashCode();
      if (ContentType != 0) hash ^= ContentType.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(Name);
      }
      if (OriginalName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteBytes(OriginalName);
      }
      if (Table.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(Table);
      }
      if (OriginalTable.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(OriginalTable);
      }
      if (Schema.Length != 0) {
        output.WriteRawTag(50);
        output.WriteBytes(Schema);
      }
      if (Catalog.Length != 0) {
        output.WriteRawTag(58);
        output.WriteBytes(Catalog);
      }
      if (Collation != 0UL) {
        output.WriteRawTag(64);
        output.WriteUInt64(Collation);
      }
      if (FractionalDigits != 0) {
        output.WriteRawTag(72);
        output.WriteUInt32(FractionalDigits);
      }
      if (Length != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Length);
      }
      if (Flags != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(Flags);
      }
      if (ContentType != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(ContentType);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Name);
      }
      if (OriginalName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OriginalName);
      }
      if (Table.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Table);
      }
      if (OriginalTable.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OriginalTable);
      }
      if (Schema.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Schema);
      }
      if (Catalog.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Catalog);
      }
      if (Collation != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Collation);
      }
      if (FractionalDigits != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FractionalDigits);
      }
      if (Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Length);
      }
      if (Flags != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      if (ContentType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContentType);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ColumnMetaData other) {
      if (other == null) {
        return;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.OriginalName.Length != 0) {
        OriginalName = other.OriginalName;
      }
      if (other.Table.Length != 0) {
        Table = other.Table;
      }
      if (other.OriginalTable.Length != 0) {
        OriginalTable = other.OriginalTable;
      }
      if (other.Schema.Length != 0) {
        Schema = other.Schema;
      }
      if (other.Catalog.Length != 0) {
        Catalog = other.Catalog;
      }
      if (other.Collation != 0UL) {
        Collation = other.Collation;
      }
      if (other.FractionalDigits != 0) {
        FractionalDigits = other.FractionalDigits;
      }
      if (other.Length != 0) {
        Length = other.Length;
      }
      if (other.Flags != 0) {
        Flags = other.Flags;
      }
      if (other.ContentType != 0) {
        ContentType = other.ContentType;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            type_ = (global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType) input.ReadEnum();
            break;
          }
          case 18: {
            Name = input.ReadBytes();
            break;
          }
          case 26: {
            OriginalName = input.ReadBytes();
            break;
          }
          case 34: {
            Table = input.ReadBytes();
            break;
          }
          case 42: {
            OriginalTable = input.ReadBytes();
            break;
          }
          case 50: {
            Schema = input.ReadBytes();
            break;
          }
          case 58: {
            Catalog = input.ReadBytes();
            break;
          }
          case 64: {
            Collation = input.ReadUInt64();
            break;
          }
          case 72: {
            FractionalDigits = input.ReadUInt32();
            break;
          }
          case 80: {
            Length = input.ReadUInt32();
            break;
          }
          case 88: {
            Flags = input.ReadUInt32();
            break;
          }
          case 96: {
            ContentType = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ColumnMetaData message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    internal static partial class Types {
      internal enum FieldType {
        [pbr::OriginalName("NONE")] None = 0,
        [pbr::OriginalName("SINT")] Sint = 1,
        [pbr::OriginalName("UINT")] Uint = 2,
        [pbr::OriginalName("DOUBLE")] Double = 5,
        [pbr::OriginalName("FLOAT")] Float = 6,
        [pbr::OriginalName("BYTES")] Bytes = 7,
        [pbr::OriginalName("TIME")] Time = 10,
        [pbr::OriginalName("DATETIME")] Datetime = 12,
        [pbr::OriginalName("SET")] Set = 15,
        [pbr::OriginalName("ENUM")] Enum = 16,
        [pbr::OriginalName("BIT")] Bit = 17,
        [pbr::OriginalName("DECIMAL")] Decimal = 18,
      }

    }
    #endregion

  }

  /// <summary>
  ///    Row in a Resultset
  ///
  ///    a row is represented as a list of fields encoded as byte blobs.
  ///    Blob of size 0 represents the NULL value. Otherwise, if it contains at least
  ///    one byte, it encodes a non-null value of the field using encoding appropriate for the
  ///    type of the value given by ``ColumnMetadata``, as specified
  ///    in the :protobuf:msg:`Mysqlx.Resultset::ColumnMetaData` description.
  /// </summary>
  internal sealed partial class Row : pb::IMessage<Row> {
    private static readonly pb::MessageParser<Row> _parser = new pb::MessageParser<Row>(() => new Row());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Row> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row(Row other) : this() {
      field_ = other.field_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Row Clone() {
      return new Row(this);
    }

    /// <summary>Field number for the "field" field.</summary>
    public const int FieldFieldNumber = 1;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_field_codec
        = pb::FieldCodec.ForBytes(10);
    private readonly pbc::RepeatedField<pb::ByteString> field_ = new pbc::RepeatedField<pb::ByteString>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> Field {
      get { return field_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Row);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Row other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!field_.Equals(other.field_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= field_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      field_.WriteTo(output, _repeated_field_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += field_.CalculateSize(_repeated_field_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Row other) {
      if (other == null) {
        return;
      }
      field_.Add(other.field_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            field_.AddEntriesFrom(input, _repeated_field_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
